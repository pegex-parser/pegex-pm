=head1 Pegex Syntax

Pegex has a fairly simple set of syntax constructs. This document details them
all.

A grammar file/text is split up into two parts: A Meta section, and a Rule
section:

=head2 Meta Statements

Meta statements are similar to the percent-prefixed declarations found in
yacc, bison, flex, and other parsers:

    # This is the Pegex grammar for Pegex grammars!
    %grammar pegex
    %version 0.1.0

A rule definition will end the meta section.

=head2 Rules

Most of a Pegex grammar is just a set of named rules.  They look like this:

    rule_name_1: <rule>* <body> /1/
    rule_name_2: /rule body 2/

A rule is a name, followed by a ':', followed by a rule body.  It can optionally
end with a semicolon, if you want to put more than one on a line.

=head3 Basic Tokens

Pegex only has 3 kinds of basic tokens:

=over

=item Rule Reference

A rule reference is the name of a rule inside angle brackets.  The brackets
are optional (in most cases; see below).

    <sub_rule_name>
    sub_rule_name
    
It can have a number of prefix modifiers:
    
    # FIXME: What do these mean???
    =<rule>  # Assertion?
    !<rule>  # Anti-assertion?
    .<rule>  # Skip?  Parse but don't capture a subpattern?
    -<rule>  # Pass?  If wrap == 1, turn non-passes into wraps.
    +<rule>  # Wrap?  $match = [ @$match ? { $ref => $match->[0] } : () ] unless $receiver->can("got_$rule");
    
As well as suffixed quantifiers (similar to REs):

    <rule>?    # optional
    <rule>*    # 0 or more times
    <rule>+    # 1 or more times
    <rule>8    # exactly 8 times
    <rule>2+   # 2 or more times
    <rule>2-3  # 2 or 3 times
    <rule>1-6  # 1 to 6 times

Note that you must use angle brackets if you are using a numbered modifier:

    rule8    # WRONG!  This would match rule "rule8".
    rule2+   # WRONG!  This would match rule "rule2", 1 or more times.
    rule2-3  # This -might- work, but it's certainly unreadable and risky.

Pre-defined "L<Pegex::Grammar::Atoms|Atoms>" exist to enchance readability
and allow for characters that normally cannot be used (like slash or hash):

    <TILDE>   # ~
    <SLASH>   # /
    <HASH>    # # (literal)
    <QMARK>   # ? (literal)
    <STAR>    # * (literal)
    <LPAREN>  # ( (literal)
    <RPAREN>  # ) (literal)
    <WORD>    # \w
    <WS>      # \s
    <ws>      # <WS>*
    
The full list can be found in the L<https://metacpan.org/source/Pegex::Grammar::Atoms|Atoms source code>. 
    
=item Regular Expression

A regular expression is a string inside forward slashes.

    /regular expression/

The RE syntax mostly follows Perl, with the following exceptions:
    
    # The syntax implies a /x modifier, so whitespace is ignored.
    / ( <rule1> | <rule2> ) /
    
    # Whitespace is declared with a tilde.
    / ~ <rule3> ~ /  # ~ is essentially <ws>
    
    # FIXME: WTF?  I don't even???
    / (: <this> | <that> ) /  # just like (?: ) syntax
    
=item Error Message

An error message is a string inside backticks.

    `error message`

The error message looks like this:

    Error parsing Pegex document:
      msg: $msg
      line: $line
      column: $column
      context: "$context"
      position: $position

The Parser's C<throw_on_error> boolean determines if it's actually
going to C<croak>, or merely stuff the error into C<$@>.  (Default
is yes.)

=back

Rule tokens can be arranged in various ways:

    ~                       # whitespace tilde can be used anywhere
    <token>                 # just a single token
    <token1> <token2>       # both tokens must exist (AND group)
    <token1> | <token2>     # either or (ANY group)
    ( <token> | ~ )*        # use parens to group up tokens and apply quantifiers
    .( <token> | ~ )*       # FIXME: Skip???
    <token> % <DOT>         # FIXME: Is this a split command???
    <token> %% <DOT>        # FIXME: eok?
    <token> %%% <DOT>       # FIXME: eok+bok?
    
    # This is perfectly legal
    rule_name_1: 
        / ( <token1>? ) <DOT> ~ /
        rule_name_2
        / ~ <DOT> ( <token2>? ) /
        ( <token3> | <token4>1-6 )2
